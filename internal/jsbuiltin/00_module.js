{let removeShebangLine=data=>{if("string"!=typeof data)throw new Error("unexpected input: "+data);return data.startsWith("#!")?data.replace(/^#![^\n]*/,""):data},isHttpUrl=s=>/^https?:\/\//gi.test(s),readUrlContent=url=>(jssh.log.debug("require: read content from %s",url),jssh.http.get(url)),resolveWithExtension=name=>{var extension=[".json",".js"];if(jssh.fs.exist(name)){if(!jssh.fs.stat(name).isdir)return name;var pkgFile=jssh.path.join(name,"package.json");if(jssh.fs.exist(pkgFile)){pkgFile=loadModuleFromJsonContent(pkgFile,jssh.fs.readfile(pkgFile));if(pkgFile.main)return resolveWithExtension(jssh.path.join(name,pkgFile.main))}var ext,indexFile=jssh.path.join(name,"index");if(jssh.fs.exist(indexFile))return indexFile;for(ext of extension)if(jssh.fs.exist(indexFile+ext))return indexFile+ext}else{for(let ext of extension)if(jssh.fs.exist(name+ext))return name+ext;let indexFile=jssh.path.join(name,"index");if(jssh.fs.exist(indexFile))return indexFile;for(let ext of extension)if(jssh.fs.exist(indexFile+ext))return indexFile+ext}},resolveNpmModulePath=(name,dir)=>{var paths=[];let d=dir;for(;;){var p=jssh.path.abs(jssh.path.join(d,"node_modules")),p=(paths.push(p),jssh.path.dir(d));if(p===d)break;d=p}for(let p of paths){var ret=resolveWithExtension(jssh.path.join(p,name));if(ret)return jssh.path.abs(ret)}},httpPkgSites=[{prefix:"unpkg:",getPath:name=>"https://unpkg.com/"+name}],resolveModulePath=(name,dir)=>{var ret,site,pkgName;if("."===name||name.startsWith("/")||name.startsWith("./"))return isHttpUrl(dir)?jssh.path.abs(jssh.path.join(dir,name)):(ret=resolveWithExtension(jssh.path.join(dir,name)))?jssh.path.abs(ret):jssh.path.abs(name);if(isHttpUrl(name))return name;if(name.startsWith("npm:"))return resolveNpmModulePath(name.slice("npm:".length),dir);for(site of httpPkgSites)if(name.startsWith(site.prefix))return pkgName=name.slice(site.prefix.length),site.getPath(pkgName);return resolveNpmModulePath(name,dir)},requiremodule=(name,dir=__dirname)=>{if(jssh.log.debug("require: name=%s, dir=%s",name,dir),"string"!=typeof name)throw new TypeError("module name expected string type");if(!name)throw new TypeError("empty module name");if(!dir)throw new TypeError("empty module dir");let file=resolveModulePath(name,dir);if(!file)throw new Error(`cannot resolve module "${name}" on path "${dir}"`);if(require.cache[file])return require.cache[file];try{let content="";if(isHttpUrl(file)){var res=readUrlContent(file);if(200===res.status)content=res.body;else{var res2=readUrlContent(file+".js");if(200!==res2.status)throw new Error(`http get "${file}" status "${res.status}"`);content=res2.body}file=res.url}else content=jssh.fs.readfile(file);return file.endsWith(".json")?loadModuleFromJsonContent(file):loadModuleFromJsContent(file,jssh.path.dir(file),content)}catch(err){dir=new Error(`cannot load module "${name}": ${err.message}
`+err.stack);throw dir.moduleName=name,dir.resolvedFilename=file,dir.originError=err,dir}},loadModuleFromJsonContent=(filename,content)=>require.cache[filename]=JSON.parse(content),loadModuleFromJsContent=(filename,dirname,content)=>{content=`
(function (require, module, __dirname, __filename) { var exports = module.exports; ${content=removeShebangLine(content)}
return module;
})(function require(name) {
  return requiremodule(name, "${dirname}");
}, {exports:{},parent:this}, "${dirname}", "${filename}")
`.trimStart();return require.cache[__filename]=jssh.evalfile(__filename,content).exports},require=name=>requiremodule(name,__dirname);require.cache={},jssh.require=require,jssh.requiremodule=requiremodule}
